# Amore Task Management App - MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a personal productivity app with Tweek-inspired minimal interface, featuring week view calendar, tasks with subtasks, custom colors, recurring tasks, and light/dark themes.

**Architecture:** Electron desktop app with React frontend and SQLite database. Template-based recurring task system. Hybrid data model supporting both local tasks and future calendar sync. Component-based UI with custom macOS styling.

**Tech Stack:** Electron.js, React 18, better-sqlite3, Tailwind CSS, date-fns, Vite for bundling

---

## Task 1: Project Scaffolding and Setup

**Files:**
- Create: `package.json`
- Create: `electron/main.js`
- Create: `electron/preload.js`
- Create: `src/main.jsx`
- Create: `src/App.jsx`
- Create: `index.html`
- Create: `vite.config.js`
- Create: `tailwind.config.js`
- Create: `postcss.config.js`
- Create: `.gitignore`

**Step 1: Initialize project and install dependencies**

Run:
```bash
npm init -y
npm install electron react react-dom
npm install -D vite @vitejs/plugin-react electron-builder concurrently wait-on cross-env
npm install -D tailwindcss postcss autoprefixer
npm install better-sqlite3 date-fns
npm install --save-dev @electron/rebuild
```

**Step 2: Configure Tailwind CSS**

Create `tailwind.config.js`:
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        'amore-blue': '#4A90E2',
        'amore-purple': '#9B51E0',
        'amore-green': '#27AE60',
        'amore-orange': '#F2994A',
        'amore-red': '#EB5757',
        'amore-yellow': '#F2C94C',
      }
    },
  },
  plugins: [],
}
```

Create `postcss.config.js`:
```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

**Step 3: Create Vite configuration**

Create `vite.config.js`:
```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  base: './',
  build: {
    outDir: 'dist-react',
    emptyOutDir: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

**Step 4: Create Electron main process**

Create `electron/main.js`:
```javascript
const { app, BrowserWindow } = require('electron')
const path = require('path')
const isDev = process.env.NODE_ENV === 'development'

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 1000,
    minHeight: 600,
    titleBarStyle: 'hiddenInset',
    trafficLightPosition: { x: 10, y: 10 },
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  })

  if (isDev) {
    mainWindow.loadURL('http://localhost:5173')
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile(path.join(__dirname, '../dist-react/index.html'))
  }
}

app.whenReady().then(() => {
  createWindow()

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})
```

Create `electron/preload.js`:
```javascript
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  // Database methods will be added here later
})
```

**Step 5: Create React entry point**

Create `index.html`:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Amore</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

Create `src/main.jsx`:
```javascript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

Create `src/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
```

Create `src/App.jsx`:
```javascript
import React from 'react'

function App() {
  return (
    <div className="h-screen bg-gray-50 dark:bg-gray-900">
      <div className="p-4">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
          Amore
        </h1>
      </div>
    </div>
  )
}

export default App
```

**Step 6: Update package.json scripts**

Modify `package.json` to add:
```json
{
  "name": "amore",
  "version": "1.0.0",
  "description": "A beautiful task management app for macOS",
  "main": "electron/main.js",
  "scripts": {
    "dev": "concurrently \"npm run dev:vite\" \"npm run dev:electron\"",
    "dev:vite": "vite",
    "dev:electron": "wait-on http://localhost:5173 && cross-env NODE_ENV=development electron .",
    "build": "vite build",
    "build:electron": "electron-builder",
    "rebuild": "electron-rebuild -f -w better-sqlite3"
  },
  "build": {
    "appId": "com.amore.app",
    "productName": "Amore",
    "mac": {
      "category": "public.app-category.productivity",
      "target": ["dmg"]
    },
    "files": [
      "dist-react/**/*",
      "electron/**/*",
      "package.json"
    ]
  }
}
```

**Step 7: Create .gitignore**

Create `.gitignore`:
```
node_modules/
dist-react/
dist/
*.db
*.db-journal
.DS_Store
.env
```

**Step 8: Rebuild native modules**

Run:
```bash
npm run rebuild
```

**Step 9: Test the basic app**

Run:
```bash
npm run dev
```

Expected: Electron window opens showing "Amore" heading with Tailwind styles applied.

**Step 10: Commit scaffolding**

```bash
git init
git add .
git commit -m "feat: initial project scaffolding with Electron, React, and Tailwind"
```

---

## Task 2: Database Setup and Models

**Files:**
- Create: `electron/database.js`
- Create: `electron/migrations.js`
- Modify: `electron/main.js`
- Modify: `electron/preload.js`

**Step 1: Create database initialization module**

Create `electron/database.js`:
```javascript
const Database = require('better-sqlite3')
const path = require('path')
const { app } = require('electron')

let db = null

function initDatabase() {
  const userDataPath = app.getPath('userData')
  const dbPath = path.join(userDataPath, 'amore.db')

  db = new Database(dbPath, { verbose: console.log })

  // Enable foreign keys
  db.pragma('foreign_keys = ON')

  return db
}

function getDatabase() {
  if (!db) {
    throw new Error('Database not initialized')
  }
  return db
}

function closeDatabase() {
  if (db) {
    db.close()
    db = null
  }
}

module.exports = {
  initDatabase,
  getDatabase,
  closeDatabase,
}
```

**Step 2: Create database migrations**

Create `electron/migrations.js`:
```javascript
function runMigrations(db) {
  // Create tasks table
  db.exec(`
    CREATE TABLE IF NOT EXISTS tasks (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      description TEXT,
      color TEXT DEFAULT '#4A90E2',
      date TEXT,
      completed INTEGER DEFAULT 0,
      position INTEGER DEFAULT 0,
      parent_id INTEGER,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (parent_id) REFERENCES tasks(id) ON DELETE CASCADE
    )
  `)

  // Create recurring templates table
  db.exec(`
    CREATE TABLE IF NOT EXISTS recurring_templates (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      task_id INTEGER NOT NULL,
      interval_type TEXT NOT NULL,
      interval_value INTEGER DEFAULT 1,
      days_of_week TEXT,
      start_date TEXT NOT NULL,
      end_date TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
    )
  `)

  // Create recurring completions table
  db.exec(`
    CREATE TABLE IF NOT EXISTS recurring_completions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      template_id INTEGER NOT NULL,
      completion_date TEXT NOT NULL,
      completed INTEGER DEFAULT 0,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (template_id) REFERENCES recurring_templates(id) ON DELETE CASCADE,
      UNIQUE(template_id, completion_date)
    )
  `)

  // Create settings table
  db.exec(`
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    )
  `)

  // Insert default settings
  const insertSetting = db.prepare('INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)')
  insertSetting.run('theme', JSON.stringify({ mode: 'light' }))
  insertSetting.run('week_start_day', JSON.stringify(0)) // 0 = Sunday

  console.log('Database migrations completed')
}

module.exports = { runMigrations }
```

**Step 3: Initialize database in main process**

Modify `electron/main.js` - add at top:
```javascript
const { initDatabase, closeDatabase } = require('./database')
const { runMigrations } = require('./migrations')
```

Add after `const isDev = ...` line:
```javascript
// Initialize database
let db
app.whenReady().then(() => {
  db = initDatabase()
  runMigrations(db)
  createWindow()
  // ... rest of existing code
})
```

Add before the `window-all-closed` handler:
```javascript
app.on('before-quit', () => {
  closeDatabase()
})
```

**Step 4: Create IPC handlers for database operations**

Create `electron/ipc-handlers.js`:
```javascript
const { ipcMain } = require('electron')
const { getDatabase } = require('./database')

function setupIpcHandlers() {
  // Get all tasks
  ipcMain.handle('tasks:getAll', () => {
    const db = getDatabase()
    const tasks = db.prepare('SELECT * FROM tasks ORDER BY position ASC').all()
    return tasks
  })

  // Get tasks by date
  ipcMain.handle('tasks:getByDate', (event, date) => {
    const db = getDatabase()
    const tasks = db.prepare(
      'SELECT * FROM tasks WHERE date = ? ORDER BY position ASC'
    ).all(date)
    return tasks
  })

  // Get tasks without date (Someday)
  ipcMain.handle('tasks:getSomeday', () => {
    const db = getDatabase()
    const tasks = db.prepare(
      'SELECT * FROM tasks WHERE date IS NULL AND parent_id IS NULL ORDER BY position ASC'
    ).all()
    return tasks
  })

  // Get subtasks
  ipcMain.handle('tasks:getSubtasks', (event, parentId) => {
    const db = getDatabase()
    const subtasks = db.prepare(
      'SELECT * FROM tasks WHERE parent_id = ? ORDER BY position ASC'
    ).all(parentId)
    return subtasks
  })

  // Create task
  ipcMain.handle('tasks:create', (event, task) => {
    const db = getDatabase()
    const stmt = db.prepare(`
      INSERT INTO tasks (title, description, color, date, position, parent_id)
      VALUES (?, ?, ?, ?, ?, ?)
    `)
    const result = stmt.run(
      task.title,
      task.description || null,
      task.color || '#4A90E2',
      task.date || null,
      task.position || 0,
      task.parentId || null
    )
    return { id: result.lastInsertRowid, ...task }
  })

  // Update task
  ipcMain.handle('tasks:update', (event, id, updates) => {
    const db = getDatabase()
    const fields = []
    const values = []

    Object.keys(updates).forEach(key => {
      fields.push(`${key} = ?`)
      values.push(updates[key])
    })

    values.push(id)

    const stmt = db.prepare(`
      UPDATE tasks
      SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `)
    stmt.run(...values)
    return { id, ...updates }
  })

  // Delete task
  ipcMain.handle('tasks:delete', (event, id) => {
    const db = getDatabase()
    const stmt = db.prepare('DELETE FROM tasks WHERE id = ?')
    stmt.run(id)
    return { id }
  })

  // Settings
  ipcMain.handle('settings:get', (event, key) => {
    const db = getDatabase()
    const result = db.prepare('SELECT value FROM settings WHERE key = ?').get(key)
    return result ? JSON.parse(result.value) : null
  })

  ipcMain.handle('settings:set', (event, key, value) => {
    const db = getDatabase()
    const stmt = db.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)')
    stmt.run(key, JSON.stringify(value))
    return { key, value }
  })
}

module.exports = { setupIpcHandlers }
```

**Step 5: Register IPC handlers in main**

Modify `electron/main.js` - add at top:
```javascript
const { setupIpcHandlers } = require('./ipc-handlers')
```

Add after `runMigrations(db)`:
```javascript
setupIpcHandlers()
```

**Step 6: Expose IPC in preload**

Modify `electron/preload.js`:
```javascript
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  tasks: {
    getAll: () => ipcRenderer.invoke('tasks:getAll'),
    getByDate: (date) => ipcRenderer.invoke('tasks:getByDate', date),
    getSomeday: () => ipcRenderer.invoke('tasks:getSomeday'),
    getSubtasks: (parentId) => ipcRenderer.invoke('tasks:getSubtasks', parentId),
    create: (task) => ipcRenderer.invoke('tasks:create', task),
    update: (id, updates) => ipcRenderer.invoke('tasks:update', id, updates),
    delete: (id) => ipcRenderer.invoke('tasks:delete', id),
  },
  settings: {
    get: (key) => ipcRenderer.invoke('settings:get', key),
    set: (key, value) => ipcRenderer.invoke('settings:set', key, value),
  },
})
```

**Step 7: Test database operations**

Modify `src/App.jsx` to test:
```javascript
import React, { useEffect, useState } from 'react'

function App() {
  const [tasks, setTasks] = useState([])

  useEffect(() => {
    // Test creating and fetching tasks
    async function testDatabase() {
      await window.electronAPI.tasks.create({
        title: 'Test Task',
        description: 'Testing database',
        date: '2025-10-25',
      })

      const allTasks = await window.electronAPI.tasks.getAll()
      setTasks(allTasks)
    }

    testDatabase()
  }, [])

  return (
    <div className="h-screen bg-gray-50 dark:bg-gray-900">
      <div className="p-4">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
          Amore
        </h1>
        <div className="mt-4">
          <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-300">
            Tasks: {tasks.length}
          </h2>
          <ul className="mt-2">
            {tasks.map(task => (
              <li key={task.id} className="text-gray-600 dark:text-gray-400">
                {task.title}
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  )
}

export default App
```

Run: `npm run dev`

Expected: App shows "Tasks: 1" with "Test Task" listed.

**Step 8: Commit database setup**

```bash
git add .
git commit -m "feat: add SQLite database with tasks, recurring templates, and settings"
```

---

## Task 3: State Management and Context

**Files:**
- Create: `src/contexts/ThemeContext.jsx`
- Create: `src/contexts/TaskContext.jsx`
- Create: `src/hooks/useTheme.js`
- Create: `src/hooks/useTasks.js`
- Modify: `src/App.jsx`

**Step 1: Create Theme Context**

Create `src/contexts/ThemeContext.jsx`:
```javascript
import React, { createContext, useState, useEffect } from 'react'

export const ThemeContext = createContext()

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  useEffect(() => {
    async function loadTheme() {
      const savedTheme = await window.electronAPI.settings.get('theme')
      if (savedTheme) {
        setTheme(savedTheme.mode)
        applyTheme(savedTheme.mode)
      }
    }
    loadTheme()
  }, [])

  const applyTheme = (mode) => {
    if (mode === 'dark') {
      document.documentElement.classList.add('dark')
    } else {
      document.documentElement.classList.remove('dark')
    }
  }

  const toggleTheme = async () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    applyTheme(newTheme)
    await window.electronAPI.settings.set('theme', { mode: newTheme })
  }

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}
```

**Step 2: Create Task Context**

Create `src/contexts/TaskContext.jsx`:
```javascript
import React, { createContext, useState, useCallback } from 'react'

export const TaskContext = createContext()

export function TaskProvider({ children }) {
  const [tasks, setTasks] = useState([])
  const [somedayTasks, setSomedayTasks] = useState([])

  const fetchTasks = useCallback(async () => {
    const allTasks = await window.electronAPI.tasks.getAll()
    const someday = await window.electronAPI.tasks.getSomeday()
    setTasks(allTasks)
    setSomedayTasks(someday)
  }, [])

  const createTask = useCallback(async (taskData) => {
    const newTask = await window.electronAPI.tasks.create(taskData)
    await fetchTasks()
    return newTask
  }, [fetchTasks])

  const updateTask = useCallback(async (id, updates) => {
    await window.electronAPI.tasks.update(id, updates)
    await fetchTasks()
  }, [fetchTasks])

  const deleteTask = useCallback(async (id) => {
    await window.electronAPI.tasks.delete(id)
    await fetchTasks()
  }, [fetchTasks])

  const toggleTaskComplete = useCallback(async (id, completed) => {
    await updateTask(id, { completed: completed ? 1 : 0 })
  }, [updateTask])

  return (
    <TaskContext.Provider value={{
      tasks,
      somedayTasks,
      fetchTasks,
      createTask,
      updateTask,
      deleteTask,
      toggleTaskComplete,
    }}>
      {children}
    </TaskContext.Provider>
  )
}
```

**Step 3: Create custom hooks**

Create `src/hooks/useTheme.js`:
```javascript
import { useContext } from 'react'
import { ThemeContext } from '../contexts/ThemeContext'

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

Create `src/hooks/useTasks.js`:
```javascript
import { useContext } from 'react'
import { TaskContext } from '../contexts/TaskContext'

export function useTasks() {
  const context = useContext(TaskContext)
  if (!context) {
    throw new Error('useTasks must be used within TaskProvider')
  }
  return context
}
```

**Step 4: Wrap App with providers**

Modify `src/main.jsx`:
```javascript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'
import { ThemeProvider } from './contexts/ThemeContext'
import { TaskProvider } from './contexts/TaskContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <ThemeProvider>
      <TaskProvider>
        <App />
      </TaskProvider>
    </ThemeProvider>
  </React.StrictMode>,
)
```

**Step 5: Test context in App**

Modify `src/App.jsx`:
```javascript
import React, { useEffect } from 'react'
import { useTheme } from './hooks/useTheme'
import { useTasks } from './hooks/useTasks'

function App() {
  const { theme, toggleTheme } = useTheme()
  const { tasks, fetchTasks } = useTasks()

  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  return (
    <div className="h-screen bg-gray-50 dark:bg-gray-900">
      <div className="p-4">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Amore
          </h1>
          <button
            onClick={toggleTheme}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
          </button>
        </div>
        <div className="mt-4">
          <p className="text-gray-600 dark:text-gray-400">
            Tasks: {tasks.length}
          </p>
        </div>
      </div>
    </div>
  )
}

export default App
```

Run: `npm run dev`

Expected: App shows with theme toggle button that switches between light and dark mode.

**Step 6: Commit state management**

```bash
git add .
git commit -m "feat: add theme and task context with custom hooks"
```

---

## Task 4: Core UI Components - Week View Structure

**Files:**
- Create: `src/components/WeekView.jsx`
- Create: `src/components/DayColumn.jsx`
- Create: `src/components/DayHeader.jsx`
- Create: `src/utils/dateUtils.js`
- Modify: `src/App.jsx`

**Step 1: Create date utility functions**

Create `src/utils/dateUtils.js`:
```javascript
import {
  startOfWeek,
  endOfWeek,
  eachDayOfInterval,
  format,
  addWeeks,
  subWeeks,
  isToday,
  isSameDay,
  parseISO,
} from 'date-fns'

export function getWeekDays(date = new Date(), weekStartsOn = 0) {
  const start = startOfWeek(date, { weekStartsOn })
  const end = endOfWeek(date, { weekStartsOn })
  return eachDayOfInterval({ start, end })
}

export function formatDate(date, formatStr = 'yyyy-MM-dd') {
  return format(date, formatStr)
}

export function formatDayHeader(date) {
  return {
    dayName: format(date, 'EEE'),
    dayNumber: format(date, 'd'),
    fullDate: formatDate(date),
    isToday: isToday(date),
  }
}

export function navigateWeek(currentDate, direction) {
  return direction === 'next' ? addWeeks(currentDate, 1) : subWeeks(currentDate, 1)
}

export function parseDate(dateString) {
  return parseISO(dateString)
}

export { isToday, isSameDay }
```

**Step 2: Create DayHeader component**

Create `src/components/DayHeader.jsx`:
```javascript
import React from 'react'

export function DayHeader({ dayName, dayNumber, isToday }) {
  return (
    <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700">
      <div className="flex flex-col items-center">
        <span className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">
          {dayName}
        </span>
        <span className={`
          mt-1 text-2xl font-semibold
          ${isToday
            ? 'text-blue-600 dark:text-blue-400'
            : 'text-gray-900 dark:text-white'
          }
        `}>
          {dayNumber}
        </span>
      </div>
    </div>
  )
}
```

**Step 3: Create DayColumn component**

Create `src/components/DayColumn.jsx`:
```javascript
import React from 'react'
import { DayHeader } from './DayHeader'

export function DayColumn({ date, dayName, dayNumber, isToday, tasks }) {
  return (
    <div className="flex flex-col bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 min-h-[500px]">
      <DayHeader
        dayName={dayName}
        dayNumber={dayNumber}
        isToday={isToday}
      />
      <div className="flex-1 p-3 space-y-2 overflow-y-auto">
        {tasks.length === 0 ? (
          <p className="text-sm text-gray-400 dark:text-gray-500 text-center mt-4">
            No tasks
          </p>
        ) : (
          tasks.map(task => (
            <div
              key={task.id}
              className="p-3 rounded-lg border border-gray-200 dark:border-gray-600"
              style={{ borderLeftColor: task.color, borderLeftWidth: '4px' }}
            >
              <p className="text-sm text-gray-900 dark:text-white">
                {task.title}
              </p>
            </div>
          ))
        )}
      </div>
    </div>
  )
}
```

**Step 4: Create WeekView component**

Create `src/components/WeekView.jsx`:
```javascript
import React, { useState, useEffect } from 'react'
import { DayColumn } from './DayColumn'
import { getWeekDays, formatDayHeader, formatDate, navigateWeek } from '../utils/dateUtils'
import { useTasks } from '../hooks/useTasks'

export function WeekView() {
  const [currentWeek, setCurrentWeek] = useState(new Date())
  const [weekDays, setWeekDays] = useState([])
  const { tasks } = useTasks()

  useEffect(() => {
    const days = getWeekDays(currentWeek, 0) // 0 = Sunday
    setWeekDays(days)
  }, [currentWeek])

  const getTasksForDate = (date) => {
    const dateStr = formatDate(date)
    return tasks.filter(task => task.date === dateStr && !task.parent_id)
  }

  const handlePrevWeek = () => {
    setCurrentWeek(prev => navigateWeek(prev, 'prev'))
  }

  const handleNextWeek = () => {
    setCurrentWeek(prev => navigateWeek(prev, 'next'))
  }

  const handleToday = () => {
    setCurrentWeek(new Date())
  }

  return (
    <div className="flex flex-col h-full">
      {/* Week Navigation */}
      <div className="flex items-center justify-between px-6 py-4 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center space-x-3">
          <button
            onClick={handlePrevWeek}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          >
            <span className="text-gray-600 dark:text-gray-300">‚Üê</span>
          </button>
          <button
            onClick={handleToday}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          >
            Today
          </button>
          <button
            onClick={handleNextWeek}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          >
            <span className="text-gray-600 dark:text-gray-300">‚Üí</span>
          </button>
        </div>
      </div>

      {/* Week Grid */}
      <div className="flex-1 p-6 overflow-hidden">
        <div className="grid grid-cols-7 gap-3 h-full">
          {weekDays.map(day => {
            const headerInfo = formatDayHeader(day)
            return (
              <DayColumn
                key={headerInfo.fullDate}
                date={day}
                dayName={headerInfo.dayName}
                dayNumber={headerInfo.dayNumber}
                isToday={headerInfo.isToday}
                tasks={getTasksForDate(day)}
              />
            )
          })}
        </div>
      </div>
    </div>
  )
}
```

**Step 5: Update App to use WeekView**

Modify `src/App.jsx`:
```javascript
import React, { useEffect } from 'react'
import { useTheme } from './hooks/useTheme'
import { useTasks } from './hooks/useTasks'
import { WeekView } from './components/WeekView'

function App() {
  const { theme, toggleTheme } = useTheme()
  const { fetchTasks } = useTasks()

  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="flex items-center justify-between px-6 py-3 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <h1 className="text-xl font-bold text-gray-900 dark:text-white">
          Amore
        </h1>
        <button
          onClick={toggleTheme}
          className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          title="Toggle theme"
        >
          <span className="text-xl">{theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}</span>
        </button>
      </div>

      {/* Main Content */}
      <div className="flex-1 overflow-hidden">
        <WeekView />
      </div>
    </div>
  )
}

export default App
```

**Step 6: Test week view**

Run: `npm run dev`

Expected: App shows a week view with 7 day columns (Sun-Sat), navigation arrows, "Today" button, and tasks appearing in their respective days.

**Step 7: Commit week view**

```bash
git add .
git commit -m "feat: add week view with day columns and navigation"
```

---

## Task 5: Task Card Component with Subtasks

**Files:**
- Create: `src/components/TaskCard.jsx`
- Create: `src/components/SubtaskList.jsx`
- Create: `src/components/Checkbox.jsx`
- Modify: `src/components/DayColumn.jsx`

**Step 1: Create Checkbox component**

Create `src/components/Checkbox.jsx`:
```javascript
import React from 'react'

export function Checkbox({ checked, onChange, size = 'md' }) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
  }

  return (
    <button
      onClick={onChange}
      className={`
        ${sizeClasses[size]}
        flex items-center justify-center
        rounded border-2
        ${checked
          ? 'bg-blue-500 border-blue-500'
          : 'bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600'
        }
        hover:border-blue-400
        transition-colors
      `}
      aria-label={checked ? 'Mark incomplete' : 'Mark complete'}
    >
      {checked && (
        <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
        </svg>
      )}
    </button>
  )
}
```

**Step 2: Create SubtaskList component**

Create `src/components/SubtaskList.jsx`:
```javascript
import React, { useState, useEffect } from 'react'
import { Checkbox } from './Checkbox'
import { useTasks } from '../hooks/useTasks'

export function SubtaskList({ parentId }) {
  const [subtasks, setSubtasks] = useState([])
  const [isExpanded, setIsExpanded] = useState(true)
  const { toggleTaskComplete } = useTasks()

  useEffect(() => {
    loadSubtasks()
  }, [parentId])

  async function loadSubtasks() {
    const subs = await window.electronAPI.tasks.getSubtasks(parentId)
    setSubtasks(subs)
  }

  const handleToggle = async (subtask) => {
    await toggleTaskComplete(subtask.id, !subtask.completed)
    await loadSubtasks()
  }

  if (subtasks.length === 0) return null

  return (
    <div className="mt-2 pl-2">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="text-xs text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 mb-1"
      >
        {isExpanded ? '‚ñº' : '‚ñ∂'} {subtasks.length} subtask{subtasks.length !== 1 ? 's' : ''}
      </button>

      {isExpanded && (
        <div className="space-y-1 mt-1">
          {subtasks.map(subtask => (
            <div key={subtask.id} className="flex items-start space-x-2 group">
              <Checkbox
                checked={!!subtask.completed}
                onChange={() => handleToggle(subtask)}
                size="sm"
              />
              <span className={`
                text-xs flex-1
                ${subtask.completed
                  ? 'line-through text-gray-400 dark:text-gray-500'
                  : 'text-gray-700 dark:text-gray-300'
                }
              `}>
                {subtask.title}
              </span>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

**Step 3: Create TaskCard component**

Create `src/components/TaskCard.jsx`:
```javascript
import React from 'react'
import { Checkbox } from './Checkbox'
import { SubtaskList } from './SubtaskList'
import { useTasks } from '../hooks/useTasks'

export function TaskCard({ task, onEdit, onDelete }) {
  const { toggleTaskComplete } = useTasks()

  const handleToggle = async () => {
    await toggleTaskComplete(task.id, !task.completed)
  }

  return (
    <div
      className="group p-3 rounded-lg bg-white dark:bg-gray-700 border-2 hover:shadow-md transition-shadow"
      style={{
        borderLeftColor: task.color,
        borderLeftWidth: '4px',
        borderTopColor: '#e5e7eb',
        borderRightColor: '#e5e7eb',
        borderBottomColor: '#e5e7eb',
      }}
    >
      <div className="flex items-start space-x-3">
        <Checkbox
          checked={!!task.completed}
          onChange={handleToggle}
        />

        <div className="flex-1 min-w-0">
          <p className={`
            text-sm font-medium
            ${task.completed
              ? 'line-through text-gray-400 dark:text-gray-500'
              : 'text-gray-900 dark:text-white'
            }
          `}>
            {task.title}
          </p>

          {task.description && (
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
              {task.description}
            </p>
          )}

          <SubtaskList parentId={task.id} />
        </div>

        {/* Actions - shown on hover */}
        <div className="opacity-0 group-hover:opacity-100 transition-opacity flex space-x-1">
          <button
            onClick={() => onEdit?.(task)}
            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-600 rounded"
            title="Edit task"
          >
            <span className="text-xs">‚úèÔ∏è</span>
          </button>
          <button
            onClick={() => onDelete?.(task.id)}
            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-600 rounded"
            title="Delete task"
          >
            <span className="text-xs">üóëÔ∏è</span>
          </button>
        </div>
      </div>
    </div>
  )
}
```

**Step 4: Update DayColumn to use TaskCard**

Modify `src/components/DayColumn.jsx`:
```javascript
import React from 'react'
import { DayHeader } from './DayHeader'
import { TaskCard } from './TaskCard'
import { useTasks } from '../hooks/useTasks'

export function DayColumn({ date, dayName, dayNumber, isToday, tasks }) {
  const { deleteTask } = useTasks()

  const handleDelete = async (taskId) => {
    if (confirm('Delete this task?')) {
      await deleteTask(taskId)
    }
  }

  return (
    <div className="flex flex-col bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 min-h-[500px]">
      <DayHeader
        dayName={dayName}
        dayNumber={dayNumber}
        isToday={isToday}
      />
      <div className="flex-1 p-3 space-y-2 overflow-y-auto">
        {tasks.length === 0 ? (
          <p className="text-sm text-gray-400 dark:text-gray-500 text-center mt-4">
            No tasks
          </p>
        ) : (
          tasks.map(task => (
            <TaskCard
              key={task.id}
              task={task}
              onDelete={handleDelete}
            />
          ))
        )}
      </div>
    </div>
  )
}
```

**Step 5: Add some test subtasks to database**

Add to `src/App.jsx` temporarily for testing (remove after):
```javascript
useEffect(() => {
  async function testSubtasks() {
    // Create parent task
    const parent = await window.electronAPI.tasks.create({
      title: 'Project Planning',
      description: 'Plan the new feature',
      date: '2025-10-27',
      color: '#9B51E0',
    })

    // Create subtasks
    await window.electronAPI.tasks.create({
      title: 'Research competitors',
      parentId: parent.id,
    })
    await window.electronAPI.tasks.create({
      title: 'Create wireframes',
      parentId: parent.id,
    })
    await window.electronAPI.tasks.create({
      title: 'Write spec document',
      parentId: parent.id,
    })

    fetchTasks()
  }

  // Run only once
  testSubtasks()
}, [])
```

Run: `npm run dev`

Expected: Tasks now appear as rounded cards with checkboxes, expandable subtask lists, and hover actions for edit/delete.

**Step 6: Remove test code and commit**

Remove the test code from `src/App.jsx`, then:

```bash
git add .
git commit -m "feat: add TaskCard component with subtasks and checkboxes"
```

---

## Task 6: Task Editor Modal

**Files:**
- Create: `src/components/TaskEditor.jsx`
- Create: `src/components/ColorPicker.jsx`
- Create: `src/components/FloatingAddButton.jsx`
- Modify: `src/App.jsx`

**Step 1: Create ColorPicker component**

Create `src/components/ColorPicker.jsx`:
```javascript
import React from 'react'

const PRESET_COLORS = [
  { name: 'Blue', value: '#4A90E2' },
  { name: 'Purple', value: '#9B51E0' },
  { name: 'Green', value: '#27AE60' },
  { name: 'Orange', value: '#F2994A' },
  { name: 'Red', value: '#EB5757' },
  { name: 'Yellow', value: '#F2C94C' },
]

export function ColorPicker({ selected, onChange }) {
  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        Color
      </label>
      <div className="flex space-x-2">
        {PRESET_COLORS.map(color => (
          <button
            key={color.value}
            onClick={() => onChange(color.value)}
            className={`
              w-8 h-8 rounded-full border-2 transition-all
              ${selected === color.value
                ? 'border-gray-900 dark:border-white scale-110'
                : 'border-transparent hover:scale-105'
              }
            `}
            style={{ backgroundColor: color.value }}
            title={color.name}
          />
        ))}
      </div>
    </div>
  )
}
```

**Step 2: Create TaskEditor modal**

Create `src/components/TaskEditor.jsx`:
```javascript
import React, { useState, useEffect } from 'react'
import { ColorPicker } from './ColorPicker'
import { useTasks } from '../hooks/useTasks'
import { formatDate } from '../utils/dateUtils'

export function TaskEditor({ isOpen, onClose, task, initialDate }) {
  const { createTask, updateTask } = useTasks()
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    color: '#4A90E2',
    date: initialDate || formatDate(new Date()),
  })
  const [subtasks, setSubtasks] = useState([])
  const [newSubtask, setNewSubtask] = useState('')

  useEffect(() => {
    if (task) {
      setFormData({
        title: task.title,
        description: task.description || '',
        color: task.color,
        date: task.date || '',
      })
      loadSubtasks()
    } else {
      resetForm()
    }
  }, [task, isOpen])

  const resetForm = () => {
    setFormData({
      title: '',
      description: '',
      color: '#4A90E2',
      date: initialDate || formatDate(new Date()),
    })
    setSubtasks([])
    setNewSubtask('')
  }

  const loadSubtasks = async () => {
    if (task?.id) {
      const subs = await window.electronAPI.tasks.getSubtasks(task.id)
      setSubtasks(subs)
    }
  }

  const handleSubmit = async (e) => {
    e.preventDefault()

    if (!formData.title.trim()) return

    if (task) {
      // Update existing task
      await updateTask(task.id, formData)
    } else {
      // Create new task
      const newTask = await createTask(formData)

      // Create subtasks if any
      for (const subtask of subtasks) {
        if (subtask.title.trim()) {
          await createTask({
            title: subtask.title,
            parentId: newTask.id,
            date: formData.date,
          })
        }
      }
    }

    onClose()
  }

  const handleAddSubtask = () => {
    if (newSubtask.trim()) {
      setSubtasks([...subtasks, { title: newSubtask, tempId: Date.now() }])
      setNewSubtask('')
    }
  }

  const handleRemoveSubtask = (index) => {
    setSubtasks(subtasks.filter((_, i) => i !== index))
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            {task ? 'Edit Task' : 'New Task'}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            ‚úï
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-4 space-y-4">
          {/* Title */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Title *
            </label>
            <input
              type="text"
              value={formData.title}
              onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500"
              placeholder="Task title"
              autoFocus
            />
          </div>

          {/* Description */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Description
            </label>
            <textarea
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 resize-none"
              rows={3}
              placeholder="Add details..."
            />
          </div>

          {/* Date */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Date
            </label>
            <input
              type="date"
              value={formData.date || ''}
              onChange={(e) => setFormData({ ...formData, date: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500"
            />
            <button
              type="button"
              onClick={() => setFormData({ ...formData, date: null })}
              className="text-xs text-blue-600 dark:text-blue-400 mt-1 hover:underline"
            >
              Move to Someday
            </button>
          </div>

          {/* Color */}
          <ColorPicker
            selected={formData.color}
            onChange={(color) => setFormData({ ...formData, color })}
          />

          {/* Subtasks */}
          {!task && (
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Subtasks
              </label>
              <div className="space-y-2">
                {subtasks.map((subtask, index) => (
                  <div key={subtask.tempId || subtask.id} className="flex items-center space-x-2">
                    <input
                      type="text"
                      value={subtask.title}
                      readOnly
                      className="flex-1 px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-white"
                    />
                    <button
                      type="button"
                      onClick={() => handleRemoveSubtask(index)}
                      className="text-red-500 hover:text-red-700"
                    >
                      ‚úï
                    </button>
                  </div>
                ))}
                <div className="flex space-x-2">
                  <input
                    type="text"
                    value={newSubtask}
                    onChange={(e) => setNewSubtask(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddSubtask())}
                    className="flex-1 px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                    placeholder="Add subtask..."
                  />
                  <button
                    type="button"
                    onClick={handleAddSubtask}
                    className="px-3 py-1 text-sm bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded"
                  >
                    + Add
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Actions */}
          <div className="flex justify-end space-x-2 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
            >
              {task ? 'Save' : 'Create'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
```

**Step 3: Create FloatingAddButton**

Create `src/components/FloatingAddButton.jsx`:
```javascript
import React from 'react'

export function FloatingAddButton({ onClick }) {
  return (
    <button
      onClick={onClick}
      className="fixed bottom-8 right-8 w-14 h-14 bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-lg flex items-center justify-center text-2xl transition-transform hover:scale-110"
      title="Add task"
    >
      +
    </button>
  )
}
```

**Step 4: Integrate TaskEditor and FloatingAddButton in App**

Modify `src/App.jsx`:
```javascript
import React, { useEffect, useState } from 'react'
import { useTheme } from './hooks/useTheme'
import { useTasks } from './hooks/useTasks'
import { WeekView } from './components/WeekView'
import { TaskEditor } from './components/TaskEditor'
import { FloatingAddButton } from './components/FloatingAddButton'

function App() {
  const { theme, toggleTheme } = useTheme()
  const { fetchTasks } = useTasks()
  const [isEditorOpen, setIsEditorOpen] = useState(false)
  const [editingTask, setEditingTask] = useState(null)

  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  const handleCloseEditor = () => {
    setIsEditorOpen(false)
    setEditingTask(null)
  }

  const handleOpenEditor = (task = null) => {
    setEditingTask(task)
    setIsEditorOpen(true)
  }

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="flex items-center justify-between px-6 py-3 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <h1 className="text-xl font-bold text-gray-900 dark:text-white">
          Amore
        </h1>
        <button
          onClick={toggleTheme}
          className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          title="Toggle theme"
        >
          <span className="text-xl">{theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}</span>
        </button>
      </div>

      {/* Main Content */}
      <div className="flex-1 overflow-hidden">
        <WeekView onEditTask={handleOpenEditor} />
      </div>

      {/* Floating Add Button */}
      <FloatingAddButton onClick={() => handleOpenEditor()} />

      {/* Task Editor Modal */}
      <TaskEditor
        isOpen={isEditorOpen}
        onClose={handleCloseEditor}
        task={editingTask}
      />
    </div>
  )
}

export default App
```

**Step 5: Pass onEdit handler to TaskCard**

Modify `src/components/WeekView.jsx` to pass onEditTask:
```javascript
// Add prop: onEditTask
export function WeekView({ onEditTask }) {
  // ... existing code ...

  return (
    // ... existing JSX ...
    <DayColumn
      // ... existing props ...
      onEditTask={onEditTask}
    />
  )
}
```

Modify `src/components/DayColumn.jsx`:
```javascript
export function DayColumn({ date, dayName, dayNumber, isToday, tasks, onEditTask }) {
  // ... existing code ...

  <TaskCard
    key={task.id}
    task={task}
    onEdit={onEditTask}
    onDelete={handleDelete}
  />
}
```

Run: `npm run dev`

Expected: Clicking the floating "+" button opens the task editor modal. Can create tasks with title, description, date, color, and subtasks.

**Step 6: Commit task editor**

```bash
git add .
git commit -m "feat: add task editor modal with color picker and subtask creation"
```

---

## Task 7: Someday Section

**Files:**
- Create: `src/components/SomedaySection.jsx`
- Modify: `src/App.jsx`

**Step 1: Create SomedaySection component**

Create `src/components/SomedaySection.jsx`:
```javascript
import React from 'react'
import { TaskCard } from './TaskCard'
import { useTasks } from './hooks/useTasks'

export function SomedaySection({ onEditTask }) {
  const { somedayTasks, deleteTask } = useTasks()

  const handleDelete = async (taskId) => {
    if (confirm('Delete this task?')) {
      await deleteTask(taskId)
    }
  }

  return (
    <div className="border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
      <div className="px-6 py-3">
        <h2 className="text-sm font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wide">
          Someday
        </h2>
      </div>
      <div className="px-6 pb-6">
        <div className="grid grid-cols-4 gap-3">
          {somedayTasks.length === 0 ? (
            <p className="col-span-4 text-sm text-gray-400 dark:text-gray-500 text-center py-8">
              No unscheduled tasks
            </p>
          ) : (
            somedayTasks.map(task => (
              <TaskCard
                key={task.id}
                task={task}
                onEdit={onEditTask}
                onDelete={handleDelete}
              />
            ))
          )}
        </div>
      </div>
    </div>
  )
}
```

**Step 2: Add SomedaySection to App**

Modify `src/App.jsx`:
```javascript
import React, { useEffect, useState } from 'react'
import { useTheme } from './hooks/useTheme'
import { useTasks } from './hooks/useTasks'
import { WeekView } from './components/WeekView'
import { SomedaySection } from './components/SomedaySection'
import { TaskEditor } from './components/TaskEditor'
import { FloatingAddButton } from './components/FloatingAddButton'

function App() {
  const { theme, toggleTheme } = useTheme()
  const { fetchTasks } = useTasks()
  const [isEditorOpen, setIsEditorOpen] = useState(false)
  const [editingTask, setEditingTask] = useState(null)

  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  const handleCloseEditor = () => {
    setIsEditorOpen(false)
    setEditingTask(null)
  }

  const handleOpenEditor = (task = null) => {
    setEditingTask(task)
    setIsEditorOpen(true)
  }

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="flex items-center justify-between px-6 py-3 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <h1 className="text-xl font-bold text-gray-900 dark:text-white">
          Amore
        </h1>
        <button
          onClick={toggleTheme}
          className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          title="Toggle theme"
        >
          <span className="text-xl">{theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}</span>
        </button>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <div className="flex-1 overflow-hidden">
          <WeekView onEditTask={handleOpenEditor} />
        </div>

        <SomedaySection onEditTask={handleOpenEditor} />
      </div>

      {/* Floating Add Button */}
      <FloatingAddButton onClick={() => handleOpenEditor()} />

      {/* Task Editor Modal */}
      <TaskEditor
        isOpen={isEditorOpen}
        onClose={handleCloseEditor}
        task={editingTask}
      />
    </div>
  )
}

export default App
```

**Step 3: Fix import in SomedaySection**

Modify `src/components/SomedaySection.jsx` (fix import):
```javascript
import React from 'react'
import { TaskCard } from './TaskCard'
import { useTasks } from '../hooks/useTasks'
```

Run: `npm run dev`

Expected: Someday section appears below the week view. Tasks with no date appear in the Someday section in a 4-column grid.

**Step 4: Commit Someday section**

```bash
git add .
git commit -m "feat: add Someday section for unscheduled tasks"
```

---

## Task 8: Recurring Tasks System

**Files:**
- Create: `electron/recurring-tasks.js`
- Create: `src/components/RecurringOptions.jsx`
- Modify: `electron/ipc-handlers.js`
- Modify: `electron/preload.js`
- Modify: `src/components/TaskEditor.jsx`
- Modify: `src/components/WeekView.jsx`

**Step 1: Create recurring task logic**

Create `electron/recurring-tasks.js`:
```javascript
const { getDatabase } = require('./database')

function createRecurringTemplate(taskId, config) {
  const db = getDatabase()
  const stmt = db.prepare(`
    INSERT INTO recurring_templates (task_id, interval_type, interval_value, days_of_week, start_date, end_date)
    VALUES (?, ?, ?, ?, ?, ?)
  `)

  const result = stmt.run(
    taskId,
    config.intervalType,
    config.intervalValue || 1,
    config.daysOfWeek ? JSON.stringify(config.daysOfWeek) : null,
    config.startDate,
    config.endDate || null
  )

  return result.lastInsertRowid
}

function getRecurringTemplate(taskId) {
  const db = getDatabase()
  const template = db.prepare('SELECT * FROM recurring_templates WHERE task_id = ?').get(taskId)

  if (template && template.days_of_week) {
    template.days_of_week = JSON.parse(template.days_of_week)
  }

  return template
}

function generateRecurringInstances(templateId, startDate, endDate) {
  const db = getDatabase()

  // Get the template
  const template = db.prepare(`
    SELECT rt.*, t.*
    FROM recurring_templates rt
    JOIN tasks t ON rt.task_id = t.id
    WHERE rt.id = ?
  `).get(templateId)

  if (!template) return []

  const instances = []
  const start = new Date(startDate)
  const end = new Date(endDate)
  const templateStart = new Date(template.start_date)
  const templateEnd = template.end_date ? new Date(template.end_date) : null

  let currentDate = new Date(Math.max(start.getTime(), templateStart.getTime()))

  while (currentDate <= end) {
    if (templateEnd && currentDate > templateEnd) break

    let shouldInclude = false

    switch (template.interval_type) {
      case 'daily':
        shouldInclude = true
        currentDate.setDate(currentDate.getDate() + template.interval_value)
        break

      case 'weekly':
        const dayOfWeek = currentDate.getDay()
        if (template.days_of_week && template.days_of_week.includes(dayOfWeek)) {
          shouldInclude = true
        }
        currentDate.setDate(currentDate.getDate() + 1)
        break

      case 'monthly':
        shouldInclude = true
        currentDate.setMonth(currentDate.getMonth() + template.interval_value)
        break

      case 'yearly':
        shouldInclude = true
        currentDate.setFullYear(currentDate.getFullYear() + template.interval_value)
        break
    }

    if (shouldInclude && currentDate >= start && currentDate <= end) {
      const dateStr = currentDate.toISOString().split('T')[0]

      // Check if this instance is completed
      const completion = db.prepare(
        'SELECT completed FROM recurring_completions WHERE template_id = ? AND completion_date = ?'
      ).get(templateId, dateStr)

      instances.push({
        id: `recurring-${templateId}-${dateStr}`,
        templateId,
        title: template.title,
        description: template.description,
        color: template.color,
        date: dateStr,
        completed: completion ? completion.completed : 0,
        isRecurring: true,
      })
    }
  }

  return instances
}

function toggleRecurringCompletion(templateId, date, completed) {
  const db = getDatabase()
  const stmt = db.prepare(`
    INSERT INTO recurring_completions (template_id, completion_date, completed)
    VALUES (?, ?, ?)
    ON CONFLICT(template_id, completion_date)
    DO UPDATE SET completed = ?
  `)

  stmt.run(templateId, date, completed ? 1 : 0, completed ? 1 : 0)
}

function getAllRecurringInstances(startDate, endDate) {
  const db = getDatabase()
  const templates = db.prepare('SELECT id FROM recurring_templates').all()

  const allInstances = []
  templates.forEach(template => {
    const instances = generateRecurringInstances(template.id, startDate, endDate)
    allInstances.push(...instances)
  })

  return allInstances
}

module.exports = {
  createRecurringTemplate,
  getRecurringTemplate,
  generateRecurringInstances,
  toggleRecurringCompletion,
  getAllRecurringInstances,
}
```

**Step 2: Add IPC handlers for recurring tasks**

Modify `electron/ipc-handlers.js` - add at top:
```javascript
const {
  createRecurringTemplate,
  getRecurringTemplate,
  getAllRecurringInstances,
  toggleRecurringCompletion,
} = require('./recurring-tasks')
```

Add before the closing of `setupIpcHandlers` function:
```javascript
  // Recurring tasks
  ipcMain.handle('recurring:create', (event, taskId, config) => {
    const templateId = createRecurringTemplate(taskId, config)
    return { templateId }
  })

  ipcMain.handle('recurring:getTemplate', (event, taskId) => {
    return getRecurringTemplate(taskId)
  })

  ipcMain.handle('recurring:getInstances', (event, startDate, endDate) => {
    return getAllRecurringInstances(startDate, endDate)
  })

  ipcMain.handle('recurring:toggleCompletion', (event, templateId, date, completed) => {
    toggleRecurringCompletion(templateId, date, completed)
    return { success: true }
  })
```

**Step 3: Expose recurring API in preload**

Modify `electron/preload.js`:
```javascript
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('electronAPI', {
  tasks: {
    getAll: () => ipcRenderer.invoke('tasks:getAll'),
    getByDate: (date) => ipcRenderer.invoke('tasks:getByDate', date),
    getSomeday: () => ipcRenderer.invoke('tasks:getSomeday'),
    getSubtasks: (parentId) => ipcRenderer.invoke('tasks:getSubtasks', parentId),
    create: (task) => ipcRenderer.invoke('tasks:create', task),
    update: (id, updates) => ipcRenderer.invoke('tasks:update', id, updates),
    delete: (id) => ipcRenderer.invoke('tasks:delete', id),
  },
  recurring: {
    create: (taskId, config) => ipcRenderer.invoke('recurring:create', taskId, config),
    getTemplate: (taskId) => ipcRenderer.invoke('recurring:getTemplate', taskId),
    getInstances: (startDate, endDate) => ipcRenderer.invoke('recurring:getInstances', startDate, endDate),
    toggleCompletion: (templateId, date, completed) => ipcRenderer.invoke('recurring:toggleCompletion', templateId, date, completed),
  },
  settings: {
    get: (key) => ipcRenderer.invoke('settings:get', key),
    set: (key, value) => ipcRenderer.invoke('settings:set', key, value),
  },
})
```

**Step 4: Create RecurringOptions component**

Create `src/components/RecurringOptions.jsx`:
```javascript
import React, { useState } from 'react'

const WEEKDAYS = [
  { label: 'S', value: 0, name: 'Sunday' },
  { label: 'M', value: 1, name: 'Monday' },
  { label: 'T', value: 2, name: 'Tuesday' },
  { label: 'W', value: 3, name: 'Wednesday' },
  { label: 'T', value: 4, name: 'Thursday' },
  { label: 'F', value: 5, name: 'Friday' },
  { label: 'S', value: 6, name: 'Saturday' },
]

export function RecurringOptions({ config, onChange }) {
  const [intervalType, setIntervalType] = useState(config?.intervalType || 'none')
  const [intervalValue, setIntervalValue] = useState(config?.intervalValue || 1)
  const [daysOfWeek, setDaysOfWeek] = useState(config?.daysOfWeek || [])

  const handleTypeChange = (type) => {
    setIntervalType(type)
    onChange({
      intervalType: type,
      intervalValue: type === 'weekly' ? 1 : intervalValue,
      daysOfWeek: type === 'weekly' ? daysOfWeek : null,
    })
  }

  const handleIntervalChange = (value) => {
    setIntervalValue(value)
    onChange({
      intervalType,
      intervalValue: value,
      daysOfWeek: intervalType === 'weekly' ? daysOfWeek : null,
    })
  }

  const toggleDay = (day) => {
    const newDays = daysOfWeek.includes(day)
      ? daysOfWeek.filter(d => d !== day)
      : [...daysOfWeek, day].sort()

    setDaysOfWeek(newDays)
    onChange({
      intervalType,
      intervalValue,
      daysOfWeek: newDays,
    })
  }

  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        Repeat
      </label>

      <select
        value={intervalType}
        onChange={(e) => handleTypeChange(e.target.value)}
        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500"
      >
        <option value="none">Does not repeat</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="monthly">Monthly</option>
        <option value="yearly">Yearly</option>
      </select>

      {intervalType === 'weekly' && (
        <div className="mt-3">
          <label className="block text-xs text-gray-600 dark:text-gray-400 mb-2">
            Repeat on
          </label>
          <div className="flex space-x-1">
            {WEEKDAYS.map(day => (
              <button
                key={day.value}
                type="button"
                onClick={() => toggleDay(day.value)}
                className={`
                  w-8 h-8 rounded-full text-xs font-medium transition-colors
                  ${daysOfWeek.includes(day.value)
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300'
                  }
                `}
                title={day.name}
              >
                {day.label}
              </button>
            ))}
          </div>
        </div>
      )}

      {intervalType === 'daily' && (
        <div className="mt-3 flex items-center space-x-2">
          <label className="text-sm text-gray-600 dark:text-gray-400">
            Every
          </label>
          <input
            type="number"
            min="1"
            value={intervalValue}
            onChange={(e) => handleIntervalChange(parseInt(e.target.value))}
            className="w-16 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          />
          <label className="text-sm text-gray-600 dark:text-gray-400">
            day(s)
          </label>
        </div>
      )}
    </div>
  )
}
```

**Step 5: Add recurring options to TaskEditor**

Modify `src/components/TaskEditor.jsx` - add state:
```javascript
const [recurringConfig, setRecurringConfig] = useState(null)
```

Import RecurringOptions:
```javascript
import { RecurringOptions } from './RecurringOptions'
```

Add in the form (after Color Picker, before Subtasks):
```javascript
          {/* Recurring */}
          {!task && (
            <RecurringOptions
              config={recurringConfig}
              onChange={setRecurringConfig}
            />
          )}
```

Modify handleSubmit to handle recurring:
```javascript
  const handleSubmit = async (e) => {
    e.preventDefault()

    if (!formData.title.trim()) return

    if (task) {
      // Update existing task
      await updateTask(task.id, formData)
    } else {
      // Create new task
      const newTask = await createTask(formData)

      // Create recurring template if configured
      if (recurringConfig && recurringConfig.intervalType !== 'none') {
        await window.electronAPI.recurring.create(newTask.id, {
          ...recurringConfig,
          startDate: formData.date || formatDate(new Date()),
        })
      }

      // Create subtasks if any
      for (const subtask of subtasks) {
        if (subtask.title.trim()) {
          await createTask({
            title: subtask.title,
            parentId: newTask.id,
            date: formData.date,
          })
        }
      }
    }

    onClose()
  }
```

**Step 6: Update WeekView to show recurring instances**

Modify `src/components/WeekView.jsx`:
```javascript
import React, { useState, useEffect } from 'react'
import { DayColumn } from './DayColumn'
import { getWeekDays, formatDayHeader, formatDate, navigateWeek } from '../utils/dateUtils'
import { useTasks } from '../hooks/useTasks'

export function WeekView({ onEditTask }) {
  const [currentWeek, setCurrentWeek] = useState(new Date())
  const [weekDays, setWeekDays] = useState([])
  const [recurringInstances, setRecurringInstances] = useState([])
  const { tasks } = useTasks()

  useEffect(() => {
    const days = getWeekDays(currentWeek, 0)
    setWeekDays(days)
    loadRecurringInstances(days)
  }, [currentWeek])

  const loadRecurringInstances = async (days) => {
    if (days.length === 0) return
    const startDate = formatDate(days[0])
    const endDate = formatDate(days[days.length - 1])
    const instances = await window.electronAPI.recurring.getInstances(startDate, endDate)
    setRecurringInstances(instances)
  }

  const getTasksForDate = (date) => {
    const dateStr = formatDate(date)

    // Regular tasks
    const regularTasks = tasks.filter(task => task.date === dateStr && !task.parent_id)

    // Recurring instances
    const recurring = recurringInstances.filter(inst => inst.date === dateStr)

    return [...regularTasks, ...recurring]
  }

  // ... rest of the component
}
```

**Step 7: Handle recurring task completion**

Modify `src/components/TaskCard.jsx`:
```javascript
  const handleToggle = async () => {
    if (task.isRecurring) {
      await window.electronAPI.recurring.toggleCompletion(
        task.templateId,
        task.date,
        !task.completed
      )
      // Refresh the view
      window.location.reload()
    } else {
      await toggleTaskComplete(task.id, !task.completed)
    }
  }
```

Run: `npm run dev`

Expected: Can create recurring tasks with daily/weekly/monthly/yearly patterns. Recurring instances appear in the week view. Can complete individual instances.

**Step 8: Commit recurring tasks**

```bash
git add .
git commit -m "feat: add recurring tasks system with template-based instances"
```

---

## Task 9: macOS Native Styling and Polish

**Files:**
- Modify: `src/index.css`
- Modify: `electron/main.js`
- Create: `src/components/TitleBar.jsx`
- Modify: `src/App.jsx`

**Step 1: Add custom macOS title bar**

Create `src/components/TitleBar.jsx`:
```javascript
import React from 'react'
import { useTheme } from '../hooks/useTheme'

export function TitleBar() {
  const { theme, toggleTheme } = useTheme()

  return (
    <div className="drag-region h-11 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between px-20">
      <div className="flex-1"></div>

      <h1 className="text-sm font-semibold text-gray-900 dark:text-white select-none">
        Amore
      </h1>

      <div className="flex-1 flex justify-end no-drag">
        <button
          onClick={toggleTheme}
          className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors"
          title="Toggle theme"
        >
          <span className="text-base">{theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}</span>
        </button>
      </div>
    </div>
  )
}
```

**Step 2: Add macOS-specific styles**

Modify `src/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
}

/* macOS title bar dragging */
.drag-region {
  -webkit-app-region: drag;
}

.no-drag {
  -webkit-app-region: no-drag;
}

/* Custom scrollbar for macOS feel */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

.dark ::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Smooth transitions */
* {
  transition-property: background-color, border-color, color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

/* Task card animations */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.task-card {
  animation: slideIn 0.2s ease-out;
}
```

**Step 3: Update App to use TitleBar**

Modify `src/App.jsx`:
```javascript
import React, { useEffect, useState } from 'react'
import { useTasks } from './hooks/useTasks'
import { TitleBar } from './components/TitleBar'
import { WeekView } from './components/WeekView'
import { SomedaySection } from './components/SomedaySection'
import { TaskEditor } from './components/TaskEditor'
import { FloatingAddButton } from './components/FloatingAddButton'

function App() {
  const { fetchTasks } = useTasks()
  const [isEditorOpen, setIsEditorOpen] = useState(false)
  const [editingTask, setEditingTask] = useState(null)

  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  const handleCloseEditor = () => {
    setIsEditorOpen(false)
    setEditingTask(null)
  }

  const handleOpenEditor = (task = null) => {
    setEditingTask(task)
    setIsEditorOpen(true)
  }

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* Custom Title Bar */}
      <TitleBar />

      {/* Main Content */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <div className="flex-1 overflow-hidden">
          <WeekView onEditTask={handleOpenEditor} />
        </div>

        <SomedaySection onEditTask={handleOpenEditor} />
      </div>

      {/* Floating Add Button */}
      <FloatingAddButton onClick={() => handleOpenEditor()} />

      {/* Task Editor Modal */}
      <TaskEditor
        isOpen={isEditorOpen}
        onClose={handleCloseEditor}
        task={editingTask}
      />
    </div>
  )
}

export default App
```

**Step 4: Add task-card class to TaskCard**

Modify `src/components/TaskCard.jsx` - add class to outer div:
```javascript
  return (
    <div
      className="task-card group p-3 rounded-lg bg-white dark:bg-gray-700 border-2 hover:shadow-md transition-shadow"
      // ... rest of the div
    )
  )
```

**Step 5: Adjust Electron window for better macOS integration**

Modify `electron/main.js`:
```javascript
function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 1000,
    minHeight: 600,
    titleBarStyle: 'hiddenInset',
    trafficLightPosition: { x: 10, y: 10 },
    backgroundColor: '#F9FAFB',
    vibrancy: 'under-window',
    visualEffectState: 'active',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  })

  // ... rest of function
}
```

Run: `npm run dev`

Expected: App now has custom title bar with traffic lights in the top left, smooth animations, macOS-style scrollbars, and native feel.

**Step 6: Commit macOS styling**

```bash
git add .
git commit -m "feat: add macOS native styling with custom title bar and animations"
```

---

## Task 10: Final Polish and Testing

**Step 1: Add keyboard shortcuts**

Modify `src/App.jsx` to add keyboard support:
```javascript
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Cmd/Ctrl + N = New task
      if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
        e.preventDefault()
        handleOpenEditor()
      }

      // Escape = Close modal
      if (e.key === 'Escape' && isEditorOpen) {
        handleCloseEditor()
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isEditorOpen])
```

**Step 2: Add loading states**

Create `src/components/LoadingSpinner.jsx`:
```javascript
import React from 'react'

export function LoadingSpinner() {
  return (
    <div className="flex items-center justify-center h-full">
      <div className="animate-spin rounded-full h-12 w-12 border-4 border-gray-300 border-t-blue-500"></div>
    </div>
  )
}
```

**Step 3: Test all features**

Run: `npm run dev`

Test checklist:
- [ ] Create task with title, description, color, date
- [ ] Create task with subtasks
- [ ] Create recurring task (daily, weekly, monthly)
- [ ] Complete/uncomplete tasks
- [ ] Complete/uncomplete subtasks
- [ ] Complete recurring instance
- [ ] Edit task
- [ ] Delete task
- [ ] Move task to Someday (remove date)
- [ ] Navigate between weeks
- [ ] Toggle theme (light/dark)
- [ ] Keyboard shortcut: Cmd+N to create task
- [ ] Keyboard shortcut: Esc to close modal

**Step 4: Build the app**

Run:
```bash
npm run build
npm run build:electron
```

Expected: Creates a distributable `.dmg` file in the `dist` folder.

**Step 5: Final commit**

```bash
git add .
git commit -m "feat: add keyboard shortcuts and final polish"
git tag v1.0.0
```

---

## Execution Complete

Your Amore MVP is now complete with:

‚úÖ Week view calendar (Sun-Sat)
‚úÖ Task creation with colors and descriptions
‚úÖ Subtasks with collapsible lists
‚úÖ Recurring tasks (daily, weekly, monthly, yearly)
‚úÖ Custom colors per task
‚úÖ Light/dark theme toggle
‚úÖ Someday section for unscheduled tasks
‚úÖ macOS native styling
‚úÖ SQLite local storage
‚úÖ Keyboard shortcuts

**Next Steps for Phase 2:**
- Google Calendar sync
- Apple Calendar/Reminders integration
- Push notifications
- Email reminders
- Multi-day task spanning
- Drag-and-drop task rescheduling
- Task search and filtering
- Custom theme colors beyond light/dark
